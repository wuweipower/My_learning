# BFS

使用队列，一圈一圈的搜索，不断在queue中push和pop

找到一个解（队列不一定为空）或者所有解（队列最终为空）

# DFS

一条路走到黑，使用递归或者stack来实现

# Hill Climbing（爬山法）

在DFS中使用贪心法==`一个启发函数`==（选择子代中最优的进行递归）这个启发函数可以为f(n)=d(n)+w(n)

d(n)是深度,w(n)是与目标的差距

# Best-First-Search

采用**优先队列**或者堆选在结点进行扩展 这里的启发式函数是一种贪心，也就是代价最小（路径）或者离目标差别最小（寻求状态）

# Branch-and-bound

是为了找到最优的情况，在找到第一个解后将其设为一个bound，可以不断更新这个bound,如果找到了更优的。

这个算法是为解决最优解的问题，这个问题一般都是有很多可行解。

- 可以用queue实现BFS后，搜索到一个解，并且记录代价，然后搜索其他的分支，如果代价大于目前记录的代价，则不扩展，若小于则扩展，如果找到了另外一个解，并且找到的这个解的代价小于目前的，则更新，继续搜索知道队列为空，个人感觉是普通BFS中找到最优解
- 也可以使用优先队列进行搜索。个人感觉是best-first-search中找到最优解

==我们需要一个函数计算代价==

# 回溯法

DFS的一种，也是有剪枝的操作，当要扩展的结点肯定不满足解或者不是最优解的时候就回溯，也就是return到上一级。

# A*

BFS,采用的是最优优先，使用了优先队列或者堆，不同的是f(n)=g(n)+h(n)

















